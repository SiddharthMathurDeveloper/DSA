<h1 align="center"><a href="https://leetcode.com/problems/find-the-smallest-divisor-given-a-threshold/description/" target="_blank">1283. Find the Smallest Divisor Given a Threshold</a></h1>

## Problem statement:
Given an array of integers `nums` and an integer `threshold`, we will choose a positive integer `divisor`, divide all the array by it, and sum the division's result. 
Find the smallest `divisor` such that the result mentioned above is less than or equal to threshold.

Each result of the division is rounded to the nearest integer greater than or equal to that element. (For example: `7/3 = 3` and `10/2 = 5`).

The test cases are generated so that there will be an answer.


## Example 1:

```
Input: nums = [1,2,5,9], threshold = 6

Output: 5

Explanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1. 
If the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2). 
```

## Example 2:

```
Input: nums = [44,22,33,11,1], threshold = 5

Output: 44
```


## Constraints:

```
1 <= nums.length <= 5 * 10^4

1 <= nums[i] <= 10^6

nums.length <= threshold <= 10^6
```


 

## Approach:

- 
  
- 
  
-
  
- 



## Code: 

```java
public int smallestDivisor(int[] nums, int threshold) {
    int[] maxAndMinValue = getMaxAndMin(nums);  // Get the maximum and minimum values in the array
    int start = 1;  // Start divisor for binary search
    int end = maxAndMinValue[0];  // End divisor for binary search

    int ans = -1;  // Initialize the answer

    // Perform binary search until start index is less than or equal to end index
    while (start <= end) {
        int mid = start + (end - start) / 2;  // Calculate the middle divisor

        // Check if it's possible to divide the array elements with the current divisor
        if (isPossible(nums, threshold, mid)) {
            ans = mid;  // Update the answer with the current divisor
            end = mid - 1;  // Move the end index to search in the left half
        } else {
            start = mid + 1;  // Move the start index to search in the right half
        }
    }

    return ans;
}

// Get the maximum and minimum values in the array
private int[] getMaxAndMin(int[] nums) {
    int maxValue = Integer.MIN_VALUE;
    int minValue = Integer.MAX_VALUE;

    for (int num : nums) {
        maxValue = Math.max(maxValue, num);
        minValue = Math.min(minValue, num);
    }

    return new int[]{maxValue, minValue};
}

// Check if it's possible to divide the array elements with the given divisor
private boolean isPossible(int[] nums, int threshold, int divisor) {
    int sumOfElements = 0;

    // Calculate the sum of elements when divided by the current divisor
    for (int num : nums) {
        int currentSum = (int) Math.ceil((float) num / (float) divisor);
        sumOfElements += currentSum;
    }

    // Check if the sum of elements is less than or equal to the threshold
    return sumOfElements <= threshold;
}
```







## Complexity:

```
Time complexity: O(N⋅log⁡M)
Space complexity: O(1)
```

## Things I Learned:

- 
  


## Companies:

```
Coinbase -> 21
Salesforce -> 2
Airbnb -> 2
Yahoo -> 2
Expedia -> 1
```





