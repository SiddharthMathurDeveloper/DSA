<h1 align="center"><a href="https://leetcode.com/problems/search-a-2d-matrix/" target="_blank">Question</a></h1>

## Problem statement:
You are given an `m x n` integer matrix `matrix` with the following two properties:

Each row is sorted in non-decreasing order.
The first integer of each row is greater than the last integer of the previous row.
Given an integer `target`, return `true` if `target` is in `matrix` or `false` otherwise.

You must write a solution in `O(log(m * n))` time complexity.


## Example 1:

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3

Output: true
```

## Example 2:

```
Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13

Output: false
```



## Constraints:

```

m == matrix.length

n == matrix[i].length

1 <= m, n <= 100

-10^4 <= matrix[i][j], target <= 10^4
```


 

## Approach:

- 
  
- 
  
-
  
- 



## Code: 

```java
public boolean searchMatrix(int[][] matrix, int target) {
    int numRows = matrix.length;        // Get the number of rows in the matrix.
    int numCols = matrix[0].length;     // Get the number of columns in the matrix.

    int start = 0;                     // Initialize the start index for binary search.
    int end = numRows * numCols - 1;   // Initialize the end index for binary search.

    while (start <= end) {
        int mid = start + (end - start) / 2;  // Calculate the middle index.

        int row = mid / numCols;      // Calculate the row index of the middle element.
        int col = mid % numCols;      // Calculate the column index of the middle element.

        if (matrix[row][col] == target) {
            // If the middle element is equal to the target, return true.
            return true;
        }

        if (matrix[row][col] > target) {
            // If the middle element is greater than the target, search in the left half.
            end = mid - 1;
        } else {
            // If the middle element is less than the target, search in the right half.
            start = mid + 1;
        }
    }

    return false;  // If the target value is not found, return false.
}
```



## Complexity:

```
Time complexity: O(log(m * n)) 
Space complexity: O(1)
```

## Things I Learned:

- To solve this You Have to think this matrix in 1D form , converting 1D mid values to 2D values formula( int row = mid/numCols | int col = mid%numCols )
  


## Companies:

```
Facebook -> 14
Amazon -> 12
Microsoft -> 7
Bloomberg -> 5
Apple -> 4
Adobe ->3
Goldman Sachs -> 2
Oracle -> 2
Nvidia -> 2
Salesforce -> 2
```





