<h1 align="center"><a href="" target="_blank">1552. Magnetic Force Between Two Balls</a></h1>

***Aggressive Cows version on Leetcode**

## Problem statement:
In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has `n` empty baskets, 
the `ith` basket is at `position[i]`, Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.

Rick stated that magnetic force between two different balls at positions `x` and `y` is `|x - y|`.

Given the integer array position and the integer m. Return the required force.


## Example 1:

```
Input: position = [1,2,3,4,7], m = 3

Output: 3

Explanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6].
The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.

```

## Example 2:

```
Input: position = [5,4,3,2,1,1000000000], m = 2

Output: 999999999

Explanation: We can use baskets 1 and 1000000000.
```




## Constraints:

```
n == position.length

2 <= n <= 10^5
1 <= position[i] <= 10^9

All integers in position are distinct.

2 <= m <= position.length
```


 

## Approach:

- 
  
- 
  
-
  
- 



## Code: 

```java
public int maxDistance(int[] position, int m) {
    // Sort the array of positions in ascending order
    Arrays.sort(position);

    // Get the length of the position array
    int positionLength = position.length;

    // Initialize the start and end variables for binary search
    int start = 0;
    int end = position[positionLength - 1];

    // Initialize the answer variable to -1
    int ans = -1;

    // Perform binary search to find the maximum distance
    while (start <= end) {
        // Calculate the middle position
        int mid = start + (end - start) / 2;

        // Check if we can place 'm' cows with at least 'mid' distance between them
        if (canWePlace(position, mid, m)) {
            // Update the answer with the current 'mid' distance
            ans = mid;
            // Move the start pointer to the right
            start = mid + 1;
        } else {
            // If we can't place 'm' cows with 'mid' distance, move the end pointer to the left
            end = mid - 1;
        }
    }

    // Return the maximum distance where 'm' cows can be placed
    return ans;
}

// Helper method to check if we can place 'cows' cows with at least 'dist' distance between them
private boolean canWePlace(int[] stalls, int dist, int cows) {
    // Get the length of the stalls array
    int stallsLength = stalls.length;

    // Initialize the count of cows placed to 1
    int countCows = 1;

    // Initialize the position of the last placed cow to the first stall
    int lastCowPosition = stalls[0];

    // Iterate through the stalls
    for (int i = 1; i < stallsLength; i++) {
        // Check if the distance between the current stall and the last placed cow is at least 'dist'
        if (stalls[i] - lastCowPosition >= dist) {
            // If yes, place a cow at the current stall and update the last placed cow's position
            countCows++;
            lastCowPosition = stalls[i];
        }

        // Check if we have placed 'cows' cows, if so, return true
        if (countCows >= cows) {
            return true;
        }
    }

    // If we couldn't place 'cows' cows with at least 'dist' distance, return false
    return false;
}


```






## Complexity:

```
Time complexity: O(NlogN) + O(N * log(max(stalls[])-min(stalls[]))) 
Space complexity: O(1)
```

## Things I Learned:

- Sorting being Used then Binary Search ,The extra function apart from binary Search / helper function how to code 
  


## Companies:

```
Amazon -> 4
Google -> 2
Myntra -> 2
Roblox -> 1
Amazon -> 2
```





