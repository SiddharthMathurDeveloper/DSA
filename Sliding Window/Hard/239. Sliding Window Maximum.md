<h1 align="center"><a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank">239. Sliding Window Maximum</a></h1>

## Problem statement:
You are given an array of integers `nums`, there is a sliding window of size `k` which is moving from the very left of the array to the very right. You can only see the `k` numbers in the window. Each time the sliding window moves right by one position.

Return the max sliding window.


## Example 1:

```
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3

Output: [3,3,5,5,6,7]

Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

## Example 2:

```
Input: nums = [1], k = 1

Output: [1]
```



## Constraints:

```
1 <= nums.length <= 10^5
-10^4 <= nums[i] <= 10^4
1 <= k <= nums.length
```


 

## Approach (Best):

- 
  
- 
  
-
  
- 



## Code: 

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // Create a deque to store indices of elements in the sliding window.
        Deque<Integer> deque = new ArrayDeque<Integer>();
        int numsLength = nums.length;

        // The result array to store the maximum elements in each window.
        int[] ans = new int[numsLength - k + 1]; // This gives the total number of windows.

        int i = 0; // Left pointer of the sliding window.
        int j = 0; // Right pointer of the sliding window.

        int ansIndex = 0; // Index for storing elements in the 'ans' array.

        // Loop through the array using the right pointer 'j'.
        while (j < numsLength) {
            // Remove elements from the end of the deque that are smaller than the current element 'nums[j]'.
            while (deque.size() > 0 && nums[j] > deque.peekLast()) {
                deque.removeLast();
            }

            // Add the current element 'nums[j]' to the end of the deque.
            deque.addLast(nums[j]);

            // If the window size is equal to 'k', it means a valid window is formed.
            if (j - i + 1 == k) {
                // Store the maximum element in the current window at the corresponding index in the 'ans' array.
                ans[ansIndex++] = deque.getFirst();

                // If the element at the front of the deque is the element going out of the window (i.e., nums[i]),
                // remove it from the deque as it will not be part of the next window.
                if (deque.getFirst() == nums[i]) {
                    deque.removeFirst();
                }
                i++; // Move the left pointer 'i' to the right for the next window.

            }

            j++; // Move the right pointer 'j' to the right for the next window.
        }

        return ans; // Return the array containing the maximum elements for each window.
    }
}
```







## Complexity:

```
Time complexity: O(N)
Space complexity: O(N)
```

## Things I Learned:

- Using Deque to store , and how to use it [3,1](->) adding this way from last and remove from last to first [3,1] (<-)
  


## Companies:

```
Amazon -> 32
Google -> 8
Microsoft -> 6
Salesforce -> 6
Uber -> 5
Facebook -> 5
Adobe -> 4
Citadel -> 4
ByteDance -> 4
Apple -> 3
Twilio -> 3
tiktok -> 3
Bloomberg -> 2
VMware -> 2
Booking.com -> 2
DoorDash -> 2
DE Shaw -> 2
Quora -> 2
```






